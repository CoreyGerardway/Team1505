#pragma config(Sensor, dgtl1,  enc1,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  enc2,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  button,         sensorNone)
#pragma config(Motor,  port2,           testOne,       tmotorVex393, openLoop)
#pragma config(Motor,  port3,           testTwo,       tmotorVex393, openLoop)
#pragma config(Motor,  port4,           testThree,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           testFour,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define MOTOR_NUM               10			//this is the number of motors connected to the robot
#define MOTOR_MAX_VALUE         127			//to set a maximum speed value that can be sent to the robot
#define MOTOR_MIN_VALUE         (-127)	//to set a minimum speed value that cen be sent to the robot
#define MOTOR_DEFAULT_SLEW_RATE 15      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        20      // task 1/frequency in mS (about 66Hz)

string MOTOR_NAME[MOTOR_NUM] = {"leftRearWheel", "leftFrontWheel", "rightFrontWheel", "leftIntake", "rightIntake", "leftUpperArm", "leftLowerArm", "rightLowerArm", "rightUpperArm", "rightRearWheel"};
// ^ Enter motor names to be used in record code (use variable names from pragma statements). Add or remove strings from array based of MOTOR_NUM ^

#define SENSOR_NUM			1								//this is the number of sensors connected to the robot
string SENSOR_TYPE[SENSOR_NUM] = {"encoder"};
string SENSOR_NAME[SENSOR_NUM] = {"driveEnc"};
int sensorReq[SENSOR_NUM] = {0};
// ^ Enter sensor name and type in same position in each array. Use same names as variables in code. Add or remove strings based on SENSOR_NUM ^

/*
THE FUNCTION INTAKE REFERS TO THE LAUNCHER/FLYWHEEL/\/\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
THE FUNCTION INTAKE REFERS TO THE LAUNCHER/FLYWHEEL/\/\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
THE FUNCTION INTAKE REFERS TO THE LAUNCHER/FLYWHEEL/\/\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
THE FUNCTION INTAKE REFERS TO THE LAUNCHER/FLYWHEEL/\/\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
THE FUNCTION INTAKE REFERS TO THE LAUNCHER/FLYWHEEL/\/\\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
*/



#define PID_SENSOR_SCALE    9.0 // used to figure out the rpms with the gear scale on robot
#define PID_MOTOR_SCALE     -1 // used to reverse the pidDrive number to a positive (added because we didn't have time to reverse the entire way it got the negative in the 1st place) )
#define PID_DRIVE_MAX       127 // used to limit the power to the max
#define PID_DRIVE_MIN     (0) // used to limit the power to the launcher to oonly 0 or positive in
#define PID_INTEGRAL_LIMIT  50

//!!!!! values used for the PID CONTROLLER
float  pid_Kp = 2.0;
float  pid_Ki = 0.04;
float  pid_Kd = 0.0;
/*
float  pid_Kp = 2.0;
float  pid_Ki = 0.04;
float  pid_Kd = 0.0;
*/
int full = 4600; // used  for full court
int medFull = 4450; // used for 3/4
int med = 4120; //
int medSmall = 4100;
int small = 4400;
int opp = 4000;
static bool pidRPM = true;
static float pidRPMREQ;

/*
This dead band can be used with the joystick to prevent small power levels from being sent to the ROBOT
This will prevent that high pitched hum. The hum is bad
*/
#define MOTOR_DEADBAND          15			//this controls how

/*HASH_SPEED this constant is used to control the speed at which the motor reading are taken
This is used for the trace
*/
#define HASH_SPEED							35   //how many mS in between motor readings.

/* IMPORTANT NEW MOTOR TOOL
this is an array that is now used to access the motors. This will control what speed
you are sending to the motor. This tool is key for the trace and to control the motorSlew
This prevents you from over heating the motor. */
int motorReq[ MOTOR_NUM ];

//array used to hold the values of the motors you do not want to slew
//This code needs to be completed
int motorSkip[MOTOR_NUM];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
// ADVANCED programmers can manually edit individual motor slews based on what the motors are doing
int motorSlew[ MOTOR_NUM ];

int recodeMode = 0; //this is a GLOBAL variable that is used to control wether or not the recorder is being used or not.

#define STARTRECORD					Btn8U  //create links to which buttons turn on and off
#define ENDRECORD					Btn8D  //the trace mode


void drive(int leftM, int rightM);
void logBaseControl(float straight, float turn);
void mecanum(int forward,int turn,int strafe);
void armLift(int power);
void intake(int power);

void setSkipperMotors();
void setSlewRate();
int setMotor(int current, int request, int motorIndex);

bool flyWheelState = true;
float RPM = 0;
float rotation = 0.0;
int thres = 4400;
//int myCount = 0;
bool click = false;
//task MotorSlewRateTask();
//task recordAutoCode();
#include "1505C-PWM.C"
#include "1505C-MOVE2.c"
//int rightFrontWheel= 20;
//int rightRearWheel= 20;
//int rightLowerArm= 20;
//int leftIntake= 20;
//int rightUpperArm= 20;
//int leftUpperArm = 20;
//int rightIntake = 20;
//int leftLowerArm = 20;
//int leftRearWheel = 20;
//int leftFrontWheel = 20;
void clearQuads(){ // resets the encoders so that position 0 is the current position
	//	SensorValue[leftRearWheel]=0;
	//	SensorValue[rightRearWheel]=0;
	//	nMotorEncoder[leftRearWheel]=0;
	//	nMotorEncoder[rightRearWheel]=0;
}
void displayBattery(){  // ******************** NOT USED IGNORE ********************
	clearLCDLine(0);                                            // Clear line 1 (0) of the LCD
	clearLCDLine(1);                                            // Clear line 2 (1) of the LCD
	string mainBattery = "Not reading correctly";
	string backupBattery = "Not reading correctly";
	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);
	//Display the Backup battery voltage
	displayLCDString(1, 0, "Backup: ");
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');    //Build the value to be displayed
	displayNextLCDString(backupBattery); //
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	bLCDBacklight = true; // enables the backlight for the lcd
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	// All activities that occur before the competition starts
}
task rpmBelts(){
	while(true){
		if(RPM > thres/PID_SENSOR_SCALE){
			belts(127);
		}
		else{
			belts(0);
		}
	}
}


//task GetRPM () // Gets flywheel rpm every 125   NEED TO QUICKEN RESPONSE TIME
//{
//	float LastValue; // last encoder value
//	float CurrentValue; // currrent encoder value
//	float Error; // differnce between current and last value
//	string mainBattery = "Not reading correctly"; //
//	while(true){
//		if(flyWheelState)
//		{
//			LastValue = SensorValue(flyWheelSensor);
//			wait1Msec(125); // 62.5, 25
//			CurrentValue = SensorValue(flyWheelSensor);
//			Error = CurrentValue - LastValue;
//			SensorValue(flyWheelSensor) = 0;
//			rotation = (Error)/180.0;
//			RPM = rotation*480.0; //(0.4/0.9); 960, 2400
//		}
//		else if (!flyWheelState){
//			SensorValue(flyWheelSensor) = 0;
//			RPM = 0;
//			Error = 0;
//		}
//		clearLCDLine(0); // Clear line 1 (0) of the LCD
//		clearLCDLine(1); // Clear line 2 (1) of the LCD
//		displayLCDString(0, 0, "RPM: ");
//		displayNextLCDNumber(RPM*PID_SENSOR_SCALE);
//		if(nLCDButtons == 2){
//			displayLCDString(1, 0, "Power: ");
//			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
//			displayNextLCDString(mainBattery);
//		}
//		else{
//			displayLCDString(1, 0,"PIDREQ: ");
//			displayNextLCDNumber(pidRPMREQ*PID_SENSOR_SCALE);
//		}
//	}
//}

/////////////////////////////////////////////////////////////////////////////////////////
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	StartTask(MotorSlewRateTask); // starts the slew rate code
	//StartTask(GetRPM); // starts recodeing the rpm
	//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
	pidRPMREQ = 4600 / PID_SENSOR_SCALE; // sets the original value for the reqested rpm vcalue at full court aka 4600 rpm
	StartTask(pidController); // starts the pid controller
	StartTask(rpmBelts); // controls belts using rpms
	//wait1Msec(1000); // !@!@!@!@!@!@!@!@!@!@!@!@
	//drive(127,127);
	/*while(nLCDButtons != 1){
		}
	drive(127,127);
	wait1Msec(1000);
	while(nLCDButtons != 1){
		}
	drive(0,0);*/
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
	pidRPMREQ = 0 / PID_SENSOR_SCALE; // sets the original value for the reqested rpm vcalue at full court aka 4600 rpm
	StartTask(MotorSlewRateTask);
	StartTask(recordAutoCode); // would use to record autocode
	//StartTask(GetRPM); // starts to record the rpms
	StartTask(pidController); // starts the pid controller
	bool beltRun = false; // used to indicate when the belts can or can't run
	bool stopPull = true; // used to
	while (true)
	{
		logBaseControl(vexRT[Ch3],vexRT[Ch4]);
		if(pidRPM&&stopPull){
			if(abs(RPM-pidRPMREQ)<=150){
				beltRun=true;
			}
			else{
				beltRun=false;
				}
		}
		if(beltRun){
			if(vexRT[Btn6U] == 1){
				belts(127);
			}
			else if(vexRT[Btn6D]== 1){
				belts(-127);
			}
			else{
				belts(0);
			}
		}


		if(vexRT[Btn7UXmtr2]==1){ //full
			pidRPMREQ = full/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7LXmtr2]==1){//medfull
			pidRPMREQ = medFull/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7DXmtr2]==1){//med
			pidRPMREQ = med/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7RXmtr2]==1){//medsmall
			pidRPMREQ = medSmall/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn8RXmtr2]==1){//small
			pidRPMREQ = small/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn8LXmtr2]==1){//opp
			pidRPMREQ = opp/PID_SENSOR_SCALE;
		}

		/*
		if(vexRT[Btn8L]==1){//full
			pidRPMREQ = full/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn8R]==1){//medfull
			pidRPMREQ = medFull/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7U]==1){//med
			pidRPMREQ = med/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7L]==1){//medsmall
			pidRPMREQ = medSmall/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7D]==1){//small
			pidRPMREQ = small/PID_SENSOR_SCALE;
		}
		if(vexRT[Btn7R]==1){//opp
			pidRPMREQ = opp/PID_SENSOR_SCALE;
			}
		*/
		if(vexRT[Btn5U] == 1){
			if(click){
				pidRPMREQ = pidRPMREQ+9;
				click = false;
			}
		}
		else if(vexRT[Btn5D] == 1){
			if(click){
				pidRPMREQ = pidRPMREQ-9;
				click = false;
			}
		}
		else{
			click = true;
		}

		//if(vexRT[Btn7L] == 1){
		//	pidRPMREQ = 4500/PID_SENSOR_SCALE;
		//}
		//else if(vexRT[Btn7R] == 1){
		//	pidRPMREQ = 4250/PID_SENSOR_SCALE;
		//}
		//intake(108);
		//motor[leftBackL] = 108;
		//motor[leftFrontL] = 108;
		//motor[rightBackL] = 108;
		//motor[rightFrontL] = 108;
		//if (vexRT[Btn8U] == 1 && !powUp){ laucherPowerLevel = laucherPowerLevel +3; if (laucherPowerLevel > 127) laucherPowerLevel =127; powUp = true; }
		//else if (vexRT[Btn8U]== 0){ powUp = false; } if (vexRT[Btn8D]== 1 && !powDown){ laucherPowerLevel = laucherPowerLevel -3; if (laucherPowerLevel < -127) laucherPowerLevel =-127; powDown = true; } else if (vexRT[Btn8D]== 0){ powDown = false; }
	}
}


/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
controller JACK /\/\/\/\/\/\ for single control
/*	LCD BUTTONS IGNORE!@@!@!@!@!@! FOR PROGRAMMMER!!!
if(nLCDButtons == button)
{
// do something
}
"button" is where you would put an integer that corresponds to the buttons on the VEX LCD. The buttons are:
Left = 1
Center = 2
Right = 4.
Knowing this, you can then check for combinations of buttons being pressed by summing their value. So if you wrote,
Code:
if(nLCDButtons == 6)
{
// do something
}
you would be checking to see if BOTH the CENTER and RIGHT buttons were pressed, since 2+4 = 6.

So the full table of buttons would be:

LEFT = 1
CENTER = 2
left&center = 3
RIGHT = 4
left&right = 5
center&right = 6
ALL = 7
vexRT[Ch3Xmtr2]
*/
